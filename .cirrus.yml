---
# Allow compute credits usage for collaborators and anything pushed to the
# main, staging, and trying branches. (So bors can use them.)
use_compute_credits: |
  $CIRRUS_USER_COLLABORATOR == 'true' ||
  $CIRRUS_BRANCH == $CIRRUS_DEFAULT_BRANCH ||
  $CIRRUS_BRANCH =~ 'staging|trying'


Lint_task: &task
  env:
    CACHIX_CACHE_NAME: memtree
    CACHIX_AUTH_TOKEN: >
      ENCRYPTED[80ed347b44a4127b859772f4455bea4085b4c245fcb
      0a21587ae322cb3bcb1705d2f95dc5580fa2ce60dd3550db7e7cb]
    USER: root
  container:
    image: nixery.dev/shell/cachix/nix/python3
  nix_config_file:
    path: /etc/nix/nix.conf
    from_contents: |
      experimental-features = auto-allocate-uids flakes nix-command
      auto-allocate-uids = true
      sandbox = false  # Annoying to get running in a container
  passwd_file:
    path: /etc/nix/passwd
    from_contents: |
      root:x:0:0:System administrator:/root:/bin/sh
  group_file:
    path: /etc/group
    from_contents: |
      root:x:0:
      nixbld:x:30000:
  config_script:
    - cachix use "$CACHIX_CACHE_NAME"
  build_script:
    - nix-build --pure ci.nix
  script:
    - nix-shell --pure ci.nix --run 'bork run lint'
  cache_update_script:
    - |
      [ -z "$CACHIX_AUTH_TOKEN" ] || {
        realpath ./result | cachix push "$CACHIX_CACHE_NAME"
      }

Test_task:
  <<: *task
  script:
    - nix-shell --pure ci.nix --run 'bork run test'

Integration_task:
  <<: *task
  script:
    - nix-shell --pure ci.nix --run 'python -m memtree'


flake_task:
  name: Devour the Nix flake
  <<: *task
  # Incorrect in principle, as the build depends on memtree's source but it's
  #  slow and highly-unlikely to fail without the integration task failing too
  only_if: >
    changesInclude('.cirrus.yml', '*.nix', 'flake.lock', 'pyproject.toml')
    || $CIRRUS_BRANCH == $CIRRUS_DEFAULT_BRANCH
    || $CIRRUS_BRANCH =~ 'staging|trying'
  container: &flake_container
    image: nixery.dev/shell/cachix/git/nix/python3
  build_script: []
  script: "nix run .#devour-self | tee result"
  cache_update_script: >
    [ -z "$CACHIX_AUTH_TOKEN" ] ||
    cachix push "$CACHIX_CACHE_NAME" < ./result


# Linting the CI & Nix configuration
#  using non-pinned versions through nixery.dev is “probably fine” here
yaml_task:
  name: Lint .cirrus.yml
  container:
    image: nixery.dev/shell/yamllint
  script: yamllint .cirrus.yml
  only_if: changesInclude('.cirrus.yml')

nixlint_task:
  name: Lint the Nix code
  only_if: changesInclude('.cirrus.yml', 'flake.lock', '*.nix')
  container:
    image: nixery.dev/shell/deadnix/jq
  deadcode_script: >-
    deadnix -h --fail --output-format json |
    jq -cf ./.ci/deadnix.jq > deadnix.json
  always:
    artifacts:
      path: "*.json"
      type: text/json
      format: cirrus


extraneous_task:
  name: Check `extra-dependencies.nix` for extraneous definitions
  only_if: changesInclude('.cirrus.yml', 'extra-dependencies.nix', 'flake.*')
  container: *flake_container
  script: |
    EXTRANEOUS="$(cat $(nix build --print-out-paths --no-link .#extraneous))"
    [ -z "${EXTRANEOUS}" ] || {
      echo "'extra-dependencies.nix' has extraneous definitions: ${EXTRANEOUS}"
      exit 1
    }


# Meta-task used by services like Bors or GitHub to check overall success
success_task:
  name: CI success
  container: {image: "busybox"}
  script: "exit 0"
  depends_on:
    - Check `extra-dependencies.nix` for extraneous definitions
    - Devour the Nix flake
    - Lint
    - Lint .cirrus.yml
    - Lint the Nix code
    - Test
    - Integration
